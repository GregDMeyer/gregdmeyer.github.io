[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the personal blog of Greg Kahanamoku-Meyer. You can learn more about me at my personal website, linked below."
  },
  {
    "objectID": "posts/stable_fidelity/index.html",
    "href": "posts/stable_fidelity/index.html",
    "title": "Numerically computing fidelities close to 1",
    "section": "",
    "text": "TL;DR\n\n\n\nFor two states \\(\\ket{a}\\) and \\(\\ket{b}\\), let \\(c = \\braket{a|b}/|\\braket{a|b}|\\) and \\(e = |c\\ket{a} - \\ket{b}|^2\\) (the norm squared of the difference vector between \\(c\\ket{a}\\) and \\(\\ket{b}\\)). Then the fidelity \\(\\mathcal{F} = |\\braket{a|b}|^2\\) can be computed with good numerical precision as \\[1 - \\mathcal{F} = e - e^2/4\\]\n\n\n\n\n\n\n\n\nNote\n\n\n\nI doubt I‚Äôm the first person to come up with this trick, but I wasn‚Äôt able to find it anywhere on the internet when I needed it. Let me know if you know a reference for it!\n\n\nSuppose we want to examine the fidelity \\(\\mathcal{F} = |\\braket{a|b}|^2\\) of two quantum states \\(\\ket{a}\\) and \\(\\ket{b}\\), stored as vectors of complex numbers. If \\(\\ket{a}\\) and \\(\\ket{b}\\) are very close, it is more convenient to study the ‚Äúerror‚Äù \\(\\epsilon = 1-\\mathcal{F}\\) rather than the fidelity itself. However, computing this value in the obvious way runs into problems with floating-point precision. Here‚Äôs a straightforward function computing \\(1-\\mathcal{F}\\):\n\ndef error_naive(a, b):\n    return 1 - np.abs(np.vdot(a, b))**2\n\nLet‚Äôs try plotting the measured fidelity vs.¬†actual fidelity, for a range of fidelities very close to 1:\n\n\nCode\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef generate_random_complex_unit_vector(dimension):\n    rtn = np.zeros((dimension,), dtype=np.complex64)\n    rtn += np.random.standard_normal(dimension)\n    rtn += 1j * np.random.standard_normal(dimension)\n    rtn /= np.linalg.norm(rtn)\n    return rtn\n\ndef generate_random_orthogonal_vectors(dimension):\n    a = generate_random_complex_unit_vector(dimension)\n    b = generate_random_complex_unit_vector(dimension)\n\n    # gram-schmidt, to make them orthogonal\n    b -= np.vdot(a, b) * a\n    b /= np.linalg.norm(b)\n\n    return a, b\n\ndef plot_error_measure(dimension, x_min, x_max, n_pts, error_funcs):\n    a, b = generate_random_orthogonal_vectors(dimension)\n    \n    pts = np.geomspace(x_min, x_max, n_pts)\n\n    for error_func in error_funcs:\n        results = []\n        for target_err in pts:\n            c = np.sqrt(target_err)*b + np.sqrt(1-target_err)*a\n            results.append(error_func(a, c))\n\n        plt.loglog(pts, results, label=error_func.__name__)\n    \n    plt.loglog(pts, pts, color='k', linestyle=':', label=r'$1 - \\mathcal{F}$')\n\n    plt.xlabel(r'$1-\\mathcal{F}$')\n    plt.ylabel('Result')\n\n    plt.title('Computed vs. actual fidelity')\n\n    plt.legend()\n\nplot_error_measure(\n    dimension=2**20, \n    x_min=1E-14, \n    x_max=1, \n    n_pts=21, \n    error_funcs=[error_naive]\n)\n\n\n\n\n\n\n\n\n\nThe reason for the discrepancy is that in the inner product, we are summing values \\(a_i^\\dagger b_i\\) that have magnitude \\(\\mathcal{O}(1/d)\\), but the ‚Äúimportant part‚Äù of each term (that prevents the sum from being exactly 1) is of order \\(\\mathcal{O}(\\epsilon/d)\\). If \\(\\epsilon\\) is very small, this ‚Äúcontent‚Äù will be lost to floating point errors. Instead, we‚Äôd like to figure out a way to sum that content we care about directly.\nConsider the following fact: \\[\n|\\ket{a}-\\ket{b}|^2 = 2 - 2\\mathrm{Re}\\left[ \\braket{a | b} \\right]\n\\] So, the square of the norm of the difference gives the ~vibes~ of \\(\\sqrt{\\epsilon} = |\\braket{a|b}|\\), except it cares about the relative phase between \\(\\ket{a}\\) and \\(\\ket{b}\\). The upside is that it should be numerically stable to compute, because the elements of the difference vector will be of order \\(\\mathcal{O}(\\epsilon/d)\\). The key idea is that we can use it to measure \\(\\epsilon\\) if we ensure there is no relative phase between \\(\\ket{a}\\) and \\(\\ket{b}\\).\nLet \\(c = \\braket{a|b}/|\\braket{a|b}|\\). Then by construction \\(\\braket{c a | b} = |\\braket{a | b}| = \\mathrm{Re}\\left[ \\braket{c a | b} \\right]\\). Combining this with the above, we may define \\(e = |c \\ket{a}-\\ket{b}|^2\\) and then: \\[\n|\\braket{a | b}| = 1 - e/2\n\\] and thus \\[\n1-\\mathcal{F} = 1 - |\\braket{a|b}|^2 = e - e^2/4\n\\] This is an exact expression (we didn‚Äôt use any approximations to get it), but it also will not suffer from numerical instability for values close to zero.\nPretty cool! Let‚Äôs try it:\n\ndef error_precise(a, b):\n    inner_prod = np.vdot(a, b)\n\n    # to avoid division by zero\n    if inner_prod == 0:\n        return 1.0\n        \n    c = inner_prod / np.abs(inner_prod)\n    diff = c*a - b\n    e = np.real(np.vdot(diff, diff))  # imag part is zero\n    return e - e**2 / 4\n\n\n\nCode\nplot_error_measure(\n    dimension=2**20, \n    x_min=1E-14, \n    x_max=1, \n    n_pts=21, \n    error_funcs=[error_naive, error_precise]\n)\n\n\n\n\n\n\n\n\n\nIt works super well! Yay!"
  },
  {
    "objectID": "posts/pdf_python/index.html",
    "href": "posts/pdf_python/index.html",
    "title": "Embedding runnable Python in PDFs",
    "section": "",
    "text": "One reason I am excited about starting this blog is because I have a long backlog of ‚Äúdumb stuff I have done with computers‚Äù that I want to share with the world. Here‚Äôs one of them.\nTo show you the idea, check out this PDF."
  },
  {
    "objectID": "posts/pdf_python/index.html#how-it-works",
    "href": "posts/pdf_python/index.html#how-it-works",
    "title": "Embedding runnable Python in PDFs",
    "section": "How it works",
    "text": "How it works\nA little-known (I think) feature of Python is that you can run code directly from a .zip file containing a __main__.py. Check this out:\n\necho 'print(\"it works!\")' &gt; __main__.py\nzip -q code.zip __main__.py\npython code.zip\n\nit works!\n\n\n(See this part of the Python docs.)\nNow consider the following two facts about the structure of ZIP and PDF files:\n\nPDF files start with a header that describes the version and some other information, and end with %%EOF to mark the end of the file.\nZIP files end with a directory describing, via relative byte offsets, where each part of the data in the file is stored.\n\nBut wait. This means that if we just concatenate a PDF and a ZIP file, the result will still start with the PDF header, and be a PDF until %%EOF, and the last part of the file will be the ZIP directory, which describes in relative offsets where to find the ZIP data.\nüëÄ\nSo it‚Äôs a valid file, in both formats!\nIn short, you can make a file that is both a PDF and a ZIP file by simply concatenating the two, and since it is possible to create and run ZIP files as Python, that means you can create a file that both is a valid PDF and runs as Python!\n\nAddendum\nA surprising thing that somewhat undermines the above argument about file structure is that (at least on my machine) it actually still works if you concatenate them in the ‚Äúwrong‚Äù order‚Äîthe ZIP first, then the PDF! I guess the libraries for reading PDFs and ZIP files are really robust to weird/corrupt file structures. I wonder what possibilities this opens up. Could we make a single file that is a PNG, and a PDF, and a ZIP file? It is left for the reader to explore‚Ä¶"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ancillary data",
    "section": "",
    "text": "Embedding runnable Python in PDFs\n\n\n\n\n\n\ncode\n\n\nfun\n\n\ndumb stuff with computers\n\n\n\nTired of distributing code with your manuscript? How about distributing your code as your manuscript!\n\n\n\n\n\nOct 12, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nNumerically computing fidelities close to 1\n\n\n\n\n\n\nquantum\n\n\nnumerics\n\n\n\nA trick for avoiding floating-point errors when numerically computing the fidelity of quantum state vectors.\n\n\n\n\n\nOct 10, 2024\n\n\n\n\n\n\nNo matching items"
  }
]